<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" 
        content="width=device-width, 
        initial-scale=1.0, 
        user-scalable=no" />
  <title>Template Maker</title>
</head>

<style>
    canvas {
        border:1px solid black;
        display:block;
    }
    #content
    {
        display:block;  
    }
    
    input[type="text"] 
    {
        width: 200px;
        height: 20px;
        padding-right: 50px;
    }

    input[type="submit"] 
    {
        margin-left: -50px;
        height: 25px;
        width: 50px;
        border: 0;
        -webkit-appearance: none;
    }
</style>

<body>
    <div id="drag-drop-area"></div>
    <div>
        <button onclick="saveTemplate()">Save Template</button><br>
    </div>
    <div id='content'>
    </div>
    <link href="https://transloadit.edgly.net/releases/uppy/v1.8.0/uppy.min.css" rel="stylesheet">
  
    <script src="https://transloadit.edgly.net/releases/uppy/v1.8.0/uppy.min.js"></script>
    <script>
    var filename = "";
      var uppy = Uppy.Core()
        .use(Uppy.Dashboard, {
          inline: true,
          target: '#drag-drop-area',
          width:400,
          height:200
        })
        .use(Uppy.Tus, {endpoint: 'https://master.tus.io/files/'})

      uppy.on('complete', (result) => {
        console.log('Upload complete! Weâ€™ve uploaded these files:', result.successful)
        filename = result.successful[0].tus.uploadUrl;
        loadSourcePDF(filename);
      })
    </script>

    <script src="CanvasInput.js"></script>
    <script src="reimg.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@2.2.228/build/pdf.min.js"></script>
    <script src="https://sdk.amazonaws.com/js/aws-sdk-2.1.12.min.js"></script>
    <script>
    //this tracks whether the mouse is currently dragging a selection box
    var active = false;
    
    //the current rectangle/input being drawn
    var currRect;

    //pool is a list of all eelection box objects that should be rendered on each loop
    var pool = [];
    
    // Loaded via <script> tag, create shortcut to access PDF.js exports.
    var pdfjsLib = window['pdfjs-dist/build/pdf'];

    //holds all the pdf/jpg pages that are displayed
    var canvases = [];
    
    /*
    const ID = '';
    const SECRET = '';
    const s3 = new AWS.S3({
        accessKeyId: ID,
        secretAccessKey: SECRET
    });
    */
    
    function processPDF(url)
    {
        //Get pdf from url, render each page into a canvas
        //save the canvas contents into a Base64 jpg string, and then redisplay over canvas
        //i do this so that i can draw on top of the canvas element in the redraw function()
        var loadingTask = pdfjsLib.getDocument(url);
        loadingTask.promise.then(function(pdf) {
            console.log('PDF loaded');
            for(let pageNumber = 1; pageNumber <= pdf.numPages; pageNumber++)
            {
                pdf.getPage(pageNumber).then(function(page) {
                    console.log('Page loaded');
                    
                    var scale = 1;
                    var viewport = page.getViewport({scale: scale});

                    // Prepare canvas using PDF page dimensions
                    let canvas = prepareCanvas(pageNumber);
                    canvases.push(canvas);
                    
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;
                    
                    let context = canvas.getContext('2d');
                    // Render PDF page into canvas context
                    var renderContext = {
                      canvasContext: context,
                      viewport: viewport
                    };
                    
                    var renderTask = page.render(renderContext);
                    renderTask.promise.then(function () {
                      //convert canvas contents into jpg
                      canvas.background_image.src = canvas.toDataURL('image/jpg');
                      canvas.pdf_ready = true;
                      page.cleanup();
                    });
                },
                function(error)
                {
                    console.log(error);
                });
            }
        },null);
    }
    
    function loadSourcePDF(url)
    { 
        setInterval(redraw, 10);
        console.log(url);
        processPDF(url);
    }
    
    //prepare a canvas element for the rendering process
    //adds callbacks and pdf page informationn to canvas element
    function prepareCanvas(x)
    {
        const canvas = document.createElement('canvas');
        canvas.setAttribute("id", "canvas-" + x.toString());
        canvas.setAttribute("crossorigin", "");
        //canvas.setAttribute("display", "block");
        
        document.getElementById('content').appendChild(canvas);
         
        canvas.addEventListener("touchstart", dragStart, false);
        canvas.addEventListener("touchend", dragEnd, false);
        canvas.addEventListener("touchmove", drag, false);

        canvas.addEventListener("mousedown", dragStart, false);
        canvas.addEventListener("mouseup", dragEnd, false);
        canvas.addEventListener("mousemove", drag, false);
        
        canvas.oncontextmenu = function ()
        {
            return false;     // cancel default menu
        }
        
        var background = new Image(730,1300);
        var background_loaded = false;
        background.onload = function(){
            canvas.background_loaded = true;
        }
        
        canvas.background_image = background;
        canvas.pdf_ready = false;
        
        canvas.pageNum = x;
        
        return canvas;
    }

    function dragStart(e) {
      //when drag is started, create a new rectangle, put it in the render pool, get the coordinates of the drag beginning location
      currRect = new Object();
      pool.push(currRect);
      
      currRect.canvas = e.target;
      currRect.pageNumber = currRect.canvas.pageNum;
      currRect.left = e.offsetX;
      currRect.top = e.offsetY;

      if (e.target.nodeName === "CANVAS") {
        active = true;
      }
    }

    function dragEnd(e) {
      //this is called when the mouse drag is released
 
      active = false;
      
      console.log(e.button);
      
      //if right click, delete whatever box is on top of the cursor
      if (e.button == 2)
      {
        var x = e.offsetX;
        var y = e.offsetY;
        pool.forEach(function (entry){
            if(x > entry.left && x < (entry.left + entry.width) && y > entry.top && y < (entry.top + entry.height))
            {
                entry.input.destroy();
                entry.check.destroy();
                let index = pool.indexOf(entry);
                if(index !== -1) {
                  pool.splice(index, 1);
                }
            }
        });
      }
      
      //if the total drag area is too small, delete the box because this was probably a single right click, not a drag
      if (currRect.width == null || currRect.height == null || currRect.width < 5 || currRect.height < 5)
      {
        let index = pool.indexOf(currRect);
        if(index !== -1) {
          pool.splice(index, 1);
        }
        return;
      }
      
      //on successful drag, create an input box above the selection box so that the user can type in the label
      var input = new CanvasInput({
        canvas:currRect.canvas,
        x: currRect.left - 5,
        y: currRect.top - 29
      });
      currRect.input = input;
      
      //create checkmark
      var check = new checkbox().init(currRect.canvas, currRect.left -5, currRect.top - 50, 200, 20, "Marker", false);
      check.click();
      currRect.check = check;
    }

    function drag(e) {
      //called during the drag event
      //update the current selection boxes dimensions to match the drag motion
      if (active) {
      
        e.preventDefault(); //idk what this does. Legacy code, am i right?
     
        currRect.width = (e.offsetX)-currRect.left;
        currRect.height = (e.offsetY)-currRect.top;

      }
    }
    function redraw()
    {

        canvases.forEach(function(canv)
        {
            redraw_canvas(canv);
        });
        
    }
    
    function redraw_canvas(canvas)
    {
    
        let context = canvas.getContext('2d');
       
        if (canvas.pdf_ready && canvas.background_loaded)
        {
            context.drawImage(canvas.background_image,0,0,canvas.width,canvas.height);   
        }
        
        //for every object in the render loop, render it again and note any changes to the associated text inputs
        pool.forEach(function(entry)
        {
            if(entry.canvas != canvas)
            {
                return;
            }
        
            if(entry.width == null || entry.height == null)
            {
                return;
            }   
            context.beginPath();
            context.strokeStyle = "red";
            context.rect(entry.left, entry.top, entry.width, entry.height);
            context.stroke();
            if(entry.input != null)
            {
                entry.input.render();
                entry.label = entry.input._value;
            }
            if(entry.check != null)
            {
                entry.check.draw();
                entry.is_marker = entry.check.selected;
            }
        });
    }
    
    // from https://github.com/joemaddalone/htmlstack/blob/master/src/checkbox/checkbox.js
    function checkbox() {
        var dataImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAUCAMAAADImI+JAAAAA3NCSVQICAjb4U/gAAABHVBMVEX///9ltFpZpVBSnUr4YWNIkUE/hDg4fDL/dXjyS07/dXj9bXD6a234YWP4XWD2WVv2VFfsOTzoLzHmKSvkISNpul5ouF32VFf0TE/vREfuPD7iHB5ltFpeq1RWoU1SnUr2WVtIkEA/hDjvREdSnUpWoU1SnUr0TE9ltFpltFqM1oSMz4CKz36FzHuBynaEyHmAyXV9yHN4v2x1vGr/holstGL/gYVpr19orl7/fYD/e31jq1r/dXhgpldfpVb/cXNZpVD9bXBYn1D/a236a21SnUr/Zmb4YWP4XWD/Wl32WVtIkED/VVj2VFf3VFb0TE8/hDjyS072SUs8gjY7gDXvREc4fDLuQELuPD7sOTzrMzXoLzHnLC/mKSvkISMrJIqrAAAAX3RSTlMAERERERERESIiMzMzMzMzMzMzMzNEREREREREZnd3d3d3d3eImZmq3e7//////////////////////////////////////////////////////////////////////7W/hfEAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAWdEVYdENyZWF0aW9uIFRpbWUAMTIvMjEvMTCej/OTAAAAHHRFWHRTb2Z0d2FyZQBBZG9iZSBGaXJld29ya3MgQ1M1cbXjNgAAAQJJREFUKJHNyldTwkAUBeBr771X7C0NS4Rs1myiKxsjiIIYxPL/f4YhMcNdw4wzPnle7plzP4B/nf6u634ubcOjyZ3cWurmzOL2t6N0LHaCH45k3IGpGM5O4iyLjUfO58TfzbiCol49Jp2RC8InYtfoiIX12BVV1amnG6eXTPicSu74bKPtNM157qzCswihAXKLR4bibu7ZmoEdQEDuygw56LHPT4yCqevuC3ZTAS1HcAZNva6pavn89Q8nGPNuHpqzaOy7tfVT2U1HLghfq6Vqaw7NA/duxnmVEKDVKNXe59FjsC45WK6ItgP4CGtva/gzBHJWnppJ+ZRdNqtp+cX9NV89BSxHIHexlgAAAABJRU5ErkJggg=="

        var me = {
            init: function ( stage, x, y, width, height, label, selected ) {
                me.x = x;
                me.y = y;
                me.sx = 20;
                me.sy = 0;
                if (selected)
                {
                    me.sx = 0;
                }
                me.label = label
                me.width = width;
                me.height = height;
                me.stage = stage;
                //me.stage.setAttribute( 'width', width );
                //me.stage.setAttribute( 'height', height );
                me.ctx = me.stage.getContext( '2d' );
                /*me.stage.addEventListener( "click", function () {
                    me.toggle()
                }, false )*/
                me.selected = selected;
                me.img = new Image()
                me.img.src = dataImage;
                return me
            },
            fill: function ( fillcolor ) {
                me.ctx.fillStyle = fillcolor;
                me.ctx.fillRect( me.x, me.y, me.width, me.height );


            },
            draw: function () {
                me.clear()
                if ( me.label ) {
                    if ( me.selected ) {
                        me.write( me.label, "green" )
                    } else {
                        me.write( me.label, "red" )
                    }
                }
                me.ctx.drawImage( me.img, me.sx, me.sy, 20, 20, me.x, me.y, 20, 20 )

            },
            write: function ( txt, labelcolor ) {
                me.ctx.font = '12px sans-serif';
                me.ctx.fillStyle = labelcolor;
                me.ctx.fillText( txt, me.x, me.y )

            },
            clear: function () {
                me.ctx.clearRect( 0, 0, me.width, me.height )
            },
            toggle: function () {
                if ( !me.selected ) {
                    me.sx = 0;
                    me.selected = true;
                } else {
                    me.sx = 20;
                    me.selected = false
                }
                ;
                me.stage.selected = me.selected
            },
            click: function ( func = function(){return;}) {
                function checkClick(e) 
                {
                    let x = e.offsetX;
                    let y = e.offsetY;
                    if(x > me.x && x < (me.x + me.width) && y > me.y && y < (me.y + me.height))
                    {
                        me.toggle();
                        func();
                    }
                }
                
                me.stage.addEventListener( 'click', checkClick, false );
            },
            setPos: function (x, y) {
                me.x = x;
                me.y = y;
            },
            destroy: function()
            {
                me.width = 0;
                me.height = 0;
                me.click(null);
                me = null;
            }
        }
        return me;
    };
    
    function saveTemplate()
    {
        //setInterval(redraw, 10);
        clearInterval(redraw);
        
        //does not work
        function upload(content, fileName, contentType) {
            var identityPoolId = "us-east-2:a58cf05b-8d3a-4cde-bc69-103e65f69cd3";
            var credentials = new AWS.CognitoIdentityCredentials({IdentityPoolId:identityPoolId, region:'us-east-2'});
            //var myConfig = new AWS.Config({
            //  credentials: myCredentials, region: 'us-east-2'
            //});
            
            AWS.config.credentials = credentials;

            AWS.config.credentials.get(function(err) {
              if (err) console.log(err);
              else {
                console.log(AWS.config.credentials);
                const bucketName = 'test-templates-data';
                var bucket = new AWS.S3({
                    params: {
                        Bucket: bucketName
                     }
                });
                
                var params = {
                    Key: fileName,
                    ContentType: contentType,
                    Body: content
                };
                bucket.putObject(params, function (err, data) {
                    if (err) {
                        console.log(err);
                    } else {
                        console.log(data);
                    }
                });
                var a = document.createElement("a");
                //var file = new Blob([content], {type: contentType});
                //a.href = content;//URL.createObjectURL(file);
                //a.download = fileName;
                //a.click();
              }
            });
                
        }
        
        function download(content, fileName, contentType){
            var file = new Blob([content], {type: contentType});
            var a = document.createElement('a');
            a.href = URL.createObjectURL(file);
            a.download = fileName;
            a.click();
        }
        
        function downloadURI(uri, name) {
          var link = document.createElement("a");
          link.download = name;
          link.href = uri;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          delete link;
        }
        
        console.log("Saving...");
        
        canvases.forEach(function (canv){
            //page_image = canv.toDataURL('image/jpeg');
            //download(page_image, 'tmpimage.jpg', 'image/jpeg');
            context = canv.getContext('2d');
            
            if (canv.pdf_ready && canv.background_loaded)
            {
                context.drawImage(canv.background_image,0,0,canv.width,canv.height);   
            }
            
            pool.forEach(function(entry)
            {
                if(entry.canvas != canv)
                {
                    return;
                }
                context.beginPath();
                context.fillStyle = "white";
                context.fillRect(entry.left, entry.top, entry.width, entry.height);
                context.stroke();
            });
            
            //download(canv.toDataURL('image/jpeg'), "test.jpg", 'image/jpeg');
            downloadURI(canv.toDataURL('image/jpeg'), filename + ".jpg");
            //ReImg.fromCanvas(canv).downloadPng('test.png');
        });
        
        pool.forEach(function (entry){
            entry.pctLeft = entry.left / entry.canvas.width;
            entry.pctTop = entry.top / entry.canvas.height;
            entry.pctWidth = entry.width / entry.canvas.width;
            entry.pctHeight = entry.height / entry.canvas.height;
        });
        
        jsonString = JSON.stringify(pool, null, '\t');
        
        download(jsonString, 'templatedata.json', 'text/plain');
        
    }
    
  </script>
</body>

</html>